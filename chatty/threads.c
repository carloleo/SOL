/* membox Progetto del corso di LSO 2017/2018 Dipartimento di Informatica Università di Pisa Docenti: Prencipe, Torquati  Studente: Carlo Leo Matricola: 546155  Si dichiara che il contenuto di questo file è in ogni sua parte  opera originale dell'autore*/#define _POSIX_C_SOURCE 200809L#include <libchatty.h>#include <sys/stat.h>extern volatile sig_atomic_t flag;extern configuration param;extern Queue_t * job_queque;extern int fd[2];extern int MaxHitsMessage;extern list *users_online;extern icl_hash_t *hash_table;extern pthread_cond_t  qcond; extern pthread_mutex_t qlock_online;extern pthread_mutex_t qlock ;extern pthread_mutex_t mtx_pipe;extern pthread_mutex_t mtx[]; //array di lock sulla hash tableextern pthread_mutex_t mtx_stats;extern struct statistics  chattyStats;void* signal_handler(void *arg){	arg_handler * parm = (arg_handler*) arg;	int curr_sig = 0;	FILE* statfile = NULL;	if((statfile = fopen(parm->statfilename,"a")) == NULL){		perror("FOPEN");		exit(EXIT_FAILURE);	}	while(1){		if(sigwait(&parm->set,&curr_sig) != 0){			fprintf(stderr, "SIGWAIT FAIL\n");			exit(EXIT_FAILURE);		}		switch (curr_sig) {			case SIGINT:			case SIGTERM:			case SIGQUIT:{					//printf("handler signal wake up!!\n");					//fflush(stdout);					pthread_kill(parm->tid,SIGUSR2);//mando il segnale al master in modo che il gestore setti il flag che implica la terminazione					fclose(statfile);					//pthread_exit(0);					return NULL;			}break;			case SIGUSR1:{				printStats(statfile);			}break;			default: break;		}	}}void* master(void*arg){ char *UnixPath = (char*) arg; int fd_skt = 0; //socket int fd_max = 0; //indice massimo int fd_i = 0; //indice per capire quale file descriptor è pronto int *fd_c = NULL; //puntatore per aggiungere un fd relativo a un client nella job queue int *fd_push = NULL; //puntatore usato per fd già pronto per l' I/0 int notused = 0; fd_set set,rdset; SYSCALL(fd_skt,socket(AF_UNIX,SOCK_STREAM,0),"SOCKET",-1); struct sockaddr_un sa; memset(&sa,0,sizeof(sa)); strncpy(sa.sun_path,UnixPath,strlen(UnixPath)+1); sa.sun_family = AF_UNIX;SYSCALL(notused,bind(fd_skt,(struct sockaddr*)&sa,sizeof(sa)),"BIND",-1);SYSCALL(notused,listen(fd_skt,param.maxconnections),"LISTEN",-1);//inizializzo il massimoif(fd_skt > fd_max) fd_max = fd_skt;if(fd[0] > fd_max) fd_max = fd[0];FD_ZERO(&set); //inizializzo il set di descrittori che uso nella selectFD_SET(fd_skt,&set); //aggiungo il file descriptor sul quale il server ascolta la richiesta di connessione di un clientFD_SET(fd[0],&set); //aggiungo il descrittore relativo alla pipewhile(!flag){	rdset = set; //la select modifica il rdset lo devo inizializzare ad ogni iterazione	if(flag) break;	if(select(fd_max+1,&rdset,NULL,NULL,NULL) == -1  && errno != EINTR ){		perror("SELECT");		exit(EXIT_FAILURE);	}	if(flag) break;	//i primi 3 fd sono riservati stdout,stdin,stderr	for(fd_i = 3; fd_i <= fd_max ; fd_i++){		if(FD_ISSET(fd_i,&rdset)){			fflush(stderr);			if(fd_i == fd_skt){				fd_c = (int*) calloc(1,sizeof(int));  //filedescriptor client				if((*fd_c = accept(fd_skt,NULL,0)) == -1 && errno != EINTR){					perror("ACCEPT");					exit(EXIT_FAILURE);				}				if(flag) break; 				if(!push(job_queque,(void*)fd_c,&qlock)){					fprintf(stderr, "MASTER\n");					perror("PUSH");					exit(EXIT_FAILURE);				}			}			else if(fd_i == fd[0]){//un worker ha scritto un descrittore da reinserire nel set					int fd_tmp = 0; //variabile usata per leggere dalla pipe il descrittore da reinserire nel rdset					pthread_mutex_lock(&mtx_pipe);					if(read(fd[0],&fd_tmp,sizeof(int)) < 0 && errno != EINTR ){						perror("READ ON PIPE");						exit(EXIT_FAILURE);					}					pthread_mutex_unlock(&mtx_pipe);					if(flag) break;					FD_SET(fd_tmp,&set); //inseirisco il descrittore relativo a un certo client nel set della select potrebbe effetuare altre richieste					if(fd_tmp > fd_max) fd_max = fd_tmp; //aggiorno l'indice del descrittore massimo					fflush(stdout);                }                else{//caso socket pronto per l'I\0              		FD_CLR(fd_i,&set);              		fd_max = updateMax(set,fd_max);              		if(fd_max == -1){//caso in cui fallisce updateMax              			fprintf(stderr, "UPDATEMAX FAIL\n");              			exit(EXIT_FAILURE);					}					fflush(stderr);					fd_push = (int*) calloc(1,sizeof(int));					*fd_push = fd_i;                	if(!push(job_queque,(void*)fd_push,&qlock)){						perror("PUSH!!!!!");						exit(EXIT_FAILURE);					}					if(flag) break;				}		}	}//for	if(flag) break;//il gestore ha settato il flag che implica la terminazione}//whileclose(fd_skt);pthread_cond_broadcast(&qcond);//sveglio tutti i worker sospesireturn NULL;}//mastervoid* worker(void*arg){	unsigned int len_buf = 0;	int *fd_c_tmp=NULL;	int fd_c = 0;	unsigned int index_mutex = 0;	message_t *request=NULL;//utilizzato per leggere i messaggi del client	message_hdr_t *answer=NULL; //ack per il client	message_data_t *msg = NULL; //data per il client	char *nickname_online = NULL;	int result = 0;	int notused = 0; //variabile utilizzata per syscall	SYSCALL(request,(message_t*) calloc(1,sizeof(message_t)),"CALLOC REQUEST",NULL);	SYSCALL(answer,(message_hdr_t*) calloc(1,sizeof(message_hdr_t)),"CALLOC ANSWER",NULL);	while(!flag){//flag che implica la terminazione	    memset(request->data.hdr.receiver,'\0',MAX_NAME_LENGTH+1);		memset(request->hdr.sender,'\0',MAX_NAME_LENGTH+1);		request->data.hdr.len = 0;		//estraggo un lavoro della coda;		fd_c_tmp = (int*)pop(job_queque,&qlock);		if(flag){ //la pop ritorna perchè il thread è stato svegliato per terminare			free(request);			free(answer);			return NULL;		} 		fd_c = *fd_c_tmp;		free(fd_c_tmp);		fflush(stdout);		result = readMsg(fd_c,request);//leggo messaggio di richiesta da parte del client		if(result < 0){//errore			//disconect_user(hash_table,fd_c);			//continue;			perror("READMSG FAIL");			exit(1);		}		if(!result){//utente si è disconesso			disconect_user(hash_table,fd_c);			fflush(stderr);			continue;		}		switch(request->hdr.op){			case REGISTER_OP:{//OPERAZIONE DI REGISTRZIONE				LOCK(request->hdr.sender,index_mutex,hash_table,mtx);				if(icl_hash_find(hash_table,request->hdr.sender,index_mutex) != NULL){//nickname gia in uso					UNLOCK(index_mutex,mtx);					setHeader(answer,OP_NICK_ALREADY,"");					send_ack(fd_c,answer);					write_on_pipe(fd[1],&fd_c);					continue;				}				UNLOCK(index_mutex,mtx); //nickname disponibile per la registrazione				user *curr_user = NULL;				SYSCALL(curr_user,(user*) calloc(1,sizeof(user)),"CALLOC USER HASH TABLE",NULL);				curr_user->fd = fd_c;				pthread_mutex_init(&curr_user->mtx,NULL);				SYSCALL(curr_user->history,init_circular_vector(curr_user->history,param.maxhits),"CALLOC HISTORY",NULL); //creo la struttura history				//inserisco il nuovo utente nella hash table, la precondione con cui chiamatoo la funzione è che il nickname non è stato precedentemte regitrato				//Quindi fallisce se e solo se una delle syscall interne ha esito negativo.				icl_hash_insert(hash_table,request->hdr.sender,curr_user);							//registrato implica online				online_user* usr = NULL; 				SYSCALL(usr,(online_user*) calloc(1,sizeof(online_user)),"CALLOC USER ONLINE FAIL",NULL); //alloco la struttura per l'utente online				usr->fd = fd_c;				strncpy(usr->nickname,request->hdr.sender,MAX_NAME_LENGTH+1);				SYSCALL(notused,add_user_online(users_online,usr,&qlock_online),"ADD_USER_ONLINE",0);				//mando la lista degli utenti online				SYSCALL(nickname_online,get_nickname_online(users_online,&len_buf,&qlock_online),"GET NICNAME ONLINE",NULL);				SYSCALL(msg,(message_data_t*)calloc(1,sizeof(message_data_t)),"CALLOC REGISTER_OP",NULL); //messaggio con cui manda il buffer_user_online al client;				setHeader(answer,OP_OK,"");				setData(msg,"",nickname_online,len_buf);				pthread_mutex_lock(&curr_user->mtx); //prendo la lock sull' utente				send_ack(fd_c,answer); //mando l'ack al client che ha richiesto di registrarsi				sendData(fd_c,msg);				pthread_mutex_unlock(&curr_user->mtx);// rilascio la mutex sull utente				write_on_pipe(fd[1],&fd_c);				free(nickname_online);				nickname_online = NULL;				free(msg);				msg = NULL;			}break;			case  CONNECT_OP: {//OPERAZIONE DI CONNESIONE					user* usr = NULL;					LOCK(request->hdr.sender,index_mutex,hash_table,mtx); //acquisisco la lock sulla lista di trabocco dove si trova l'utente che ha richiesto CONNECT_OP					if((usr = icl_hash_find(hash_table,request->hdr.sender,index_mutex)) != NULL){ //caso nickname registrto precedentemnete						usr->fd = fd_c; //aggiorno descrittore nella tabella hash						if(!is_online(users_online,&qlock_online,request->hdr.sender)){							online_user * u = NULL;							SYSCALL(u,(online_user*) calloc(1,sizeof(online_user)),"CALLOC USER ONLINE CONNECT_OP",NULL);							u->fd = fd_c;							strncpy(u->nickname,request->hdr.sender,MAX_NAME_LENGTH+1); //aggiungo l'utente alla lista degli utenti online							SYSCALL(notused,add_user_online(users_online,u,&qlock_online),"ADD_USER_ONLINE CONNECT_OP",0);						}	                   	UNLOCK(index_mutex,mtx); //rilascio la lock caso CONNECT_OP a buon fine						SYSCALL(nickname_online,get_nickname_online(users_online,&len_buf,&qlock_online),"GET NICNAME ONLINE CONNECT_OP",NULL);						assert(strlen(nickname_online) > 0);						SYSCALL(msg,(message_data_t*) calloc(1,sizeof(message_data_t)),"CALLOC MSG CONNECT_OP",NULL);						//mando la lista degli utenti						setHeader(answer,	OP_OK,"");						setData(msg,"",nickname_online,len_buf);						pthread_mutex_lock(&usr->mtx); // prendo la lock sull'utente						send_ack(fd_c,answer);						sendData(fd_c,msg);						pthread_mutex_unlock(&usr->mtx); //rilascio la lock sulll'utente						if(!write_on_pipe(fd[1],&fd_c)) exit(EXIT_FAILURE); //ripasso al master il descrittore servito						free(nickname_online);						nickname_online = NULL;						free(msg);						msg = NULL;						continue;					}					//caso utente non registrato					UNLOCK(index_mutex,mtx);					setHeader(answer,OP_NICK_UNKNOWN,"");					send_ack(fd_c,answer);					write_on_pipe(fd[1],&fd_c);				}break;			case  USRLIST_OP: { //*questa operzione richiede che venga effettuata prima la CONNECT_OP					//preparo la risposta					SYSCALL(msg,(message_data_t*)calloc(1,sizeof(message_data_t)),"CALLOC USRLIST_OP",NULL); //allco la parte contente i dati					SYSCALL(nickname_online,get_nickname_online(users_online,&len_buf,&qlock_online),"GET_NIKCNAME ONLINE USRLIST_OP",NULL);					setData(msg,"",nickname_online,len_buf);					setHeader(answer,OP_OK,"");					LOCK(request->hdr.sender,index_mutex,hash_table,mtx);					user * usr = icl_hash_find(hash_table,request->hdr.sender,index_mutex); //sono sicuro che l'utente è presente*					UNLOCK(index_mutex,mtx);					pthread_mutex_lock(&usr->mtx); //prendo la lock sull'utente					send_ack(fd_c,answer); 					sendData(fd_c,msg); //invio ack e lista degli utenti online					pthread_mutex_unlock(&usr->mtx); //rilascio la mutex sull' utente					write_on_pipe(fd[1],&fd_c);					free(msg);					free(nickname_online);					nickname_online = NULL;					msg = NULL;			}			case POSTTXT_OP: {//*questa operzione richiede che venga effettuata prima la CONNECT_OP					user* send = NULL;					//verifico la len del messaggio					if(request->data.hdr.len > param.maxmessagesize) setHeader(answer,OP_MSG_TOOLONG,""); //len too long					else{//len ok							user * rcv = NULL;							LOCK(request->data.hdr.receiver,index_mutex,hash_table,mtx);//prendo la lock sulla lista di trabocco							if((rcv = icl_hash_find(hash_table,request->data.hdr.receiver,index_mutex)) != NULL){//destinatario registrato								if(rcv->fd != -1){//destinatario online									UNLOCK(index_mutex,mtx); //rilacio la mutex sulla lista di trabocco									setHeader(answer,OP_OK,"");									request->hdr.op = TXT_MESSAGE;									pthread_mutex_lock(&rcv->mtx); //prendo la lock sul destinatario									sendRequest(rcv->fd,request); //invio messaggio, giro il messaggio di richiesta ricevuto. il client lo legge tutto;									pthread_mutex_unlock(&rcv->mtx);									pthread_mutex_lock(&mtx_stats); //aggiorno il numero di messaggi consegnati									chattyStats.ndelivered += 1;									pthread_mutex_unlock(&mtx_stats);								}								else{//destinatario offile									message_t *cpy = NULL;									SYSCALL(cpy,(message_t*)calloc(1,sizeof(message_t)),"CALLOC POSTTXT_OP",NULL);									*cpy = *request;							 		cpy->data.buf = strdup(request->data.buf);							 		cpy->hdr.op = TXT_MESSAGE;							 		setHeader(answer,OP_OK,"");							 		insert_msg(rcv->history,cpy); //inserimento messaggio nella history									UNLOCK(index_mutex,mtx); //rilascio la mutex sulla lista di trabocco aspetto che il messaggio venga aggiunto alla history									free(cpy->data.buf); //dealloco buffer 							 		free(cpy); //dealloco la copia inserita. (la insert non inserisce il puntatore al messagio ma lo stato del messaggio puntato)								}							}						else{//destinatario non registrato							UNLOCK(index_mutex,mtx); //rilacio la mutex sulla lista di trabocco							setHeader(answer,OP_NICK_UNKNOWN,"");						}				}				LOCK(request->hdr.sender,index_mutex,hash_table,mtx);				send = icl_hash_find(hash_table,request->hdr.sender,index_mutex); //chiamo icl_find con la precondizione che il mittente è registrato;				UNLOCK(index_mutex,mtx);				pthread_mutex_lock(&send->mtx);				send_ack(fd_c,answer);				pthread_mutex_unlock(&send->mtx);				free(request->data.buf); //libero la memoria allocata per il buffer contenente il messaggio				request->data.buf = NULL;				write_on_pipe(fd[1],&fd_c);//rimando il descrittore al master			}break;		case GETPREVMSGS_OP: { //*questa operzione richiede che venga effettuata prima la CONNECT_OP				user* send = NULL;				int riuso = 0; //flag che mi indica se ci sono stati entry riutilizzate, poichè il modo in cui recapito i messaggi cambia				int i = 0;				size_t nmess;				LOCK(request->hdr.sender,index_mutex,hash_table,mtx);//prendo la lock sulla lista di trabocco				send = icl_hash_find(hash_table,request->hdr.sender,index_mutex);				UNLOCK(index_mutex,mtx) //in questo momento l'utente è online, eventuali messaggi vengono recapitati direttamente->rilascio la lock sulla lista di trabocco				if(send->history->count_msg == 0){ //non ha messeggi da recuperare						setHeader(answer,OP_FAIL,"");						pthread_mutex_lock(&send->mtx); //prendo la lock sull'utente						send_ack(fd_c,answer); //mando esito negativo						pthread_mutex_unlock(&send->mtx);//rilacio la lock sull'utente				}				else{						SYSCALL(msg,(message_data_t*) calloc(1,sizeof(message_t)),"CALLOC GETPREVMSGS_OP",NULL);						if(send->history->count_msg >= send->history->size){//caso entry riutilizzate							int last_index = send->history->count_msg % send->history->size; //vedo l'ultima posizione riutilizzata							nmess = (size_t)last_index + (send->history->size - last_index); //a quella sommo il numero elementi che la seguono							riuso = 1;						}						else nmess = (size_t)send->history->count_msg;; //caso complementare						setHeader(answer,OP_OK,"");						setData(msg,"",(const char*)&nmess,sizeof(size_t));						pthread_mutex_lock(&send->mtx); //prendo la lock sull'utente						send_ack(fd_c,answer); //mando esito positivo						sendData(fd_c,msg);//comunico quanti messaggi non consegnati riceverà						//mando i messaggi mantenendo l'ordine con il quale sono stati inseriti nella history						if(riuso){							for(i = send->history->index_frist ; i < send->history->size ; i++) sendRequest(fd_c,&(send->history->msgs[i])); 							for(i = 0 ; i < send->history->index_frist ; i++) sendRequest(fd_c,&(send->history->msgs[i]));						}						else for(i = 0; i < send->history->count_msg ; i++) sendRequest(fd_c,&(send->history->msgs[i]));						pthread_mutex_unlock(&send->mtx);//rilacio la lock sull'utente						free(msg);						msg = NULL;						pthread_mutex_lock(&mtx_stats);						chattyStats.ndelivered += nmess;						chattyStats.nnotdelivered -= nmess;						pthread_mutex_unlock(&mtx_stats);											}				write_on_pipe(fd[1],&fd_c);//rimando il descrittore al master				 		}break;		case  POSTTXTALL_OP : { //operazione che richiede la connesione				user* send = NULL;				int error = 0;				//varifico la len del messaggio				if(request->data.hdr.len > param.maxmessagesize){					setHeader(answer,OP_MSG_TOOLONG,"");					error = 1;				} 				else{//len ok					icl_entry_t* curr = NULL;					message_t *cpy = NULL;					for(int i = 0; i < hash_table->nbuckets; i++){						pthread_mutex_lock(&mtx[i]); //prendo la lock sulla lista di trabocco    					for (curr=hash_table->buckets[i]; curr != NULL; curr=curr->next){        					user* usr = (user*) curr->data;        					if(usr->fd == fd_c) continue ; //visto nella hash table la struct relativa al mittente        					if(usr->fd != -1){//utente online								pthread_mutex_lock(&usr->mtx); //prendo la lock sul destinatario								request->hdr.op = TXT_MESSAGE;								sendRequest(usr->fd,request); //invio messaggio, giro il messaggio di richiesta ricevuto. il client lo legge tutto;								pthread_mutex_unlock(&usr->mtx);//rilascio la lock sul destinatario								pthread_mutex_lock(&mtx_stats); //aggiorno il numero di messaggi consegnati								chattyStats.ndelivered += 1;								pthread_mutex_unlock(&mtx_stats);        					}        					else{//utente offline        							SYSCALL(cpy,(message_t*)calloc(1,sizeof(message_t)),"CALLOC POSTTXT_OP",NULL);									*cpy = *request;							 		cpy->data.buf = strdup(request->data.buf);							 		cpy->hdr.op = TXT_MESSAGE;        							insert_msg(usr->history,cpy);        							free(cpy->data.buf);        							free(cpy);        							cpy = NULL;        					}						}						pthread_mutex_unlock(&mtx[i]); //rilascio la lock sulla lista di trabocco        			}				}				//mando esito operazioe				if(!error) setHeader(answer,OP_OK,"");				free(request->data.buf);				request->data.buf = NULL;				LOCK(request->hdr.sender,index_mutex,hash_table,mtx); //acquisico mtx relativa alla lista di trabocco del mittente				send = icl_hash_find(hash_table,request->hdr.sender,index_mutex); //chiamo icl_find con la precondizione che il mittente  è registrato;				UNLOCK(index_mutex,mtx);//la rilascio				pthread_mutex_lock(&send->mtx); //prendo la lock sull'utente che ha fatto richiesta				send_ack(fd_c,answer);				pthread_mutex_unlock(&send->mtx);//rilascio la lock				write_on_pipe(fd[1],&fd_c);		}break;		case  UNREGISTER_OP: { //operazione che richiede -k. Inoltre un utente puo deregistrare solo se stesso				if(strcmp(request->hdr.sender,request->data.hdr.receiver)) setHeader(answer,OP_FAIL,"");//utente che si vuole deregistrare diverso da quello che ha fatto richiesta				else{					icl_hash_delete(hash_table,request->hdr.sender,free_key,free_data); //chiamo delete con la precondizione che l'utente è presente nella hash_table					setHeader(answer,OP_OK,"");				}				send_ack(fd_c,answer); //l'utente non compare piu nella hash table, quindi nessuno puo inviarli messaggi ora				write_on_pipe(fd[1],&fd_c);		}break;		case POSTFILE_OP: { //operazione che richiede -k.				user* rcv = NULL;				user* send = NULL;				int error = 0;				LOCK(request->data.hdr.receiver,index_mutex,hash_table,mtx); //controllo che il destinatario è registrato-prendo la mutex sulla lista di trabocco				if((rcv =icl_hash_find(hash_table,request->data.hdr.receiver,index_mutex)) == NULL){					UNLOCK(index_mutex,mtx);					setHeader(answer,OP_FAIL,"");				}				else{						UNLOCK(index_mutex,mtx);//rilascio mutex su lista di trabocco						FILE * curr_file = NULL;						char *fname = NULL;						char *tmp = NULL;						if((tmp = strrchr(request->data.buf,'/')) != NULL){							tmp+= 1; 							fname = strdup(tmp);							free(request->data.buf);							request->data.buf= NULL;							setData(&request->data,"",fname,strlen(fname)+1);							SYSCALL(curr_file,fopen(fname,"w+"),"FOPEN POSTFILE_OP",NULL);						} 						else SYSCALL(curr_file,fopen(request->data.buf,"w+"),"FOPEN POSTFILE_OP",NULL);												SYSCALL(msg,(message_data_t*)calloc(1,sizeof(message_data_t)),"CALLOC POSTFILE_OP",NULL);						readData(fd_c,msg);						size_t nkbyte = msg->hdr.len / 1024; //mi manda il numero di byte						if(nkbyte > param.maxfilesize){							setHeader(answer,OP_MSG_TOOLONG,""); //dimensione too great							error = 1;						} 						else{ //dimensione ok								fwrite(msg->buf,msg->hdr.len,1,curr_file); //scrivo il buffer nel file								request->hdr.op = FILE_MESSAGE;								if(rcv->fd != -1){//rcv online										pthread_mutex_lock(&rcv->mtx);										sendRequest(rcv->fd,request); //notifico la presenza di un file al destinatario										pthread_mutex_unlock(&rcv->mtx);										setHeader(answer,OP_OK,"");										pthread_mutex_lock(&mtx_stats);        								chattyStats.nfiledelivered += 1;        								pthread_mutex_unlock(&mtx_stats);								}								else{//rcv offiline									message_t *cpy = NULL;									SYSCALL(cpy,(message_t*)calloc(1,sizeof(message_t)),"CALLOC POSTTXT_OP",NULL);									*cpy = *request;							 		cpy->data.buf = strdup(request->data.buf);							 		cpy->hdr.op =  FILE_MESSAGE;							 		LOCK(request->data.hdr.receiver,index_mutex,hash_table,mtx); //acquisisco la lock sulla lista di trabocco relativa al destinatario        							insert_msg(rcv->history,cpy);         							UNLOCK(index_mutex,mtx);//rilascio mutex su lista di trabocco        							setHeader(answer,OP_OK,"");        							free(cpy->data.buf);        							free(cpy);									cpy = NULL;        							pthread_mutex_lock(&mtx_stats);        							chattyStats.nfilenotdelivered += 1;        							pthread_mutex_unlock(&mtx_stats);								}						}						fclose(curr_file);						free(msg->buf);//buffer contente il contenuto del file						free(msg);//messaggio						msg = NULL;				}				free(request->data.buf);//libero il buffer della richiesta che contine il nome del file				request->data.buf = NULL;				LOCK(request->hdr.sender,index_mutex,hash_table,mtx); //LOCCO LISTA DI TRABOCCO MITTENTE				send = icl_hash_find(hash_table,request->hdr.sender,index_mutex);				UNLOCK(index_mutex,mtx);//UNLOKKO				pthread_mutex_lock(&send->mtx);//invio esito al mittente				send_ack(fd_c,answer);				pthread_mutex_unlock(&send->mtx);				write_on_pipe(fd[1],&fd_c);		}break;		case  GETFILE_OP :{ //operazione che richiede -k un client puo chiedermi solo file che gli sono stati  recapitati con una POSTFILR_OP, quindi sono sicurmante presenti nella cartella.			user*send = NULL;			FILE *curr_file = NULL;			char* buffer = NULL;			struct stat info;			memset((char*)&info,0,sizeof(struct stat));			SYSCALL(notused,stat(request->data.buf,&info),"STAT FAIL GETFILE_OP",-1);			SYSCALL(curr_file,fopen(request->data.buf,"r"),"FOPEN GETFILE_OP",NULL);				SYSCALL(msg,(message_data_t*)calloc(1,sizeof(message_data_t)),"CALLOC GETFILE_OP",NULL);			SYSCALL(buffer,(char*)calloc(info.st_size,sizeof(char)),"CALLOC GETFILE_OP",NULL);			fread(buffer,info.st_size,1,curr_file); //scrivo il file nel buffer del messaggio			setData(msg,"",buffer,info.st_size);			setHeader(answer,OP_OK,"");			LOCK(request->hdr.sender,index_mutex,hash_table,mtx);//lockko lista di trabocco			send = icl_hash_find(hash_table,request->hdr.sender,index_mutex);//invio file			UNLOCK(index_mutex,mtx);//unloccko lista di trabocco			pthread_mutex_lock(&send->mtx);			send_ack(send->fd,answer);			sendData(send->fd,msg);			pthread_mutex_unlock(&send->mtx);			free(buffer);			free(msg);			free(request->data.buf);			request->data.buf = NULL;			msg = NULL;			write_on_pipe(fd[1],&fd_c);		}break;		default: {			fprintf(stderr, "operazione invalida op=[%d] \n",request->hdr.op);			setHeader(answer,OP_FAIL,"");			send_ack(fd_c,answer);			write_on_pipe(fd[1],&fd_c);		}break;	}}//whilefree(request->data.buf);if(request) free(request);if(answer) free(answer);return NULL;}//worker